stages:
  - backend-setup
  - infra-initialise
  - infra-validate
  - infra-plan
  - infra-deploy

variables:
  TF_ROOT: ${CI_PROJECT_DIR}/Livrables/infra/main
  BACKEND_ROOT: ${CI_PROJECT_DIR}/Livrables/infra/backend
  TF_STATE_NAME: ${CI_COMMIT_REF_SLUG}
  TF_CACHE_KEY: ${CI_COMMIT_REF_SLUG}
  AWS_DEFAULT_REGION: "${AWS_DEFAULT_REGION:-us-east-1}"
  
  # Backend configuration (will be set by backend-setup job)
  TF_STATE_BUCKET: ""
  TF_STATE_LOCK_TABLE: ""

.backend-base:
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  before_script:
    - cd ${BACKEND_ROOT}
    - terraform --version
    - terraform init
  cache:
    key: "${TF_CACHE_KEY}"
    paths:
      - ${TF_ROOT}/.terraform/
      - ${TF_ROOT}/.terraform.lock.hcl

backend-setup:
  stage: backend-setup
  extends: .backend-base
  script:
    - echo "Setting up Terraform backend infrastructure..."
    - terraform validate
    - terraform plan -out=backend-plan
    - terraform apply -input=false backend-plan
    - echo "=== Backend Setup Complete ==="
    - terraform output -raw s3_bucket_name > ../s3_bucket.txt
    - terraform output -raw dynamodb_table_name > ../dynamodb_table.txt
    - echo "S3 Bucket $(cat ../s3_bucket.txt)"
    - echo "DynamoDB Table $(cat ../dynamodb_table.txt)"
  artifacts:
    paths:
      - s3_bucket.txt
      - dynamodb_table.txt
    expire_in: 1 day
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"'
      changes:
        - Livrables/backend/**/*
      when: manual
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - Livrables/backend/**/*
      when: manual

.terraform-base:
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  cache:
    key: "${TF_CACHE_KEY}"
    paths:
      - ${TF_ROOT}/.terraform
      - ${TF_ROOT}/.terraform.lock.hcl
  before_script:
    - cd ${TF_ROOT}
    - terraform --version
    - apk add --no-cache python3 py3-pip curl jq
    - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    - unzip awscliv2.zip
    - ./aws/install
    - aws --version
    # Get backend configuration from setup artifacts or fallback
    - |
      if [ -f "../s3_bucket.txt" ] && [ -f "../dynamodb_table.txt" ]; then
        export TF_STATE_BUCKET=$(cat ../s3_bucket.txt)
        export TF_STATE_LOCK_TABLE=$(cat ../dynamodb_table.txt)
        echo "Using backend from setup S3=$TF_STATE_BUCKET DynamoDB=$TF_STATE_LOCK_TABLE"
      else
        # Fallback to predefined values or error
        if [ -z "$TF_STATE_BUCKET" ] || [ -z "$TF_STATE_LOCK_TABLE" ]; then
          echo "ERROR Backend not configured. Run backend-setup first or set TF_STATE_BUCKET and TF_STATE_LOCK_TABLE variables"
          exit 1
        fi
        echo "Using predefined backend S3=$TF_STATE_BUCKET DynamoDB=$TF_STATE_LOCK_TABLE"
      fi
    # Create backend configuration for S3
    - |
      cat > backend.tf << EOF
      terraform {
        backend "s3" {
          bucket         = "${TF_STATE_BUCKET}"
          key            = "environments/${TF_STATE_NAME}/terraform.tfstate"
          region         = "${AWS_DEFAULT_REGION}"
          dynamodb_table = "${TF_STATE_LOCK_TABLE}"
          encrypt        = true
        }
      }
      EOF
    - terraform init -reconfigure
  dependencies:
    - backend-setup
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - Livrables/infra/**/*
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - Livrables/infra/**/*

infra-validate:
  stage: infra-validate
  extends: .terraform-base
  cache:
    key: terraform
    paths:
      - ${TF_ROOT}/.terraform
      - ${TF_ROOT}/.terraform.lock.hcl
  script:
    - terraform init -reconfigure
    - terraform validate
    - terraform fmt -check
  dependencies:
    - backend-setup
  needs:
    - infra-initialise

infra-plan:
  stage: infra-plan
  extends: .terraform-base
  cache:
    key: terraform
    paths:
      - ${TF_ROOT}/.terraform
      - ${TF_ROOT}/.terraform.lock.hcl
  script:
    - terraform init -reconfigure
    - terraform plan -input=false -out=tfplan
    - terraform show -json tfplan > tfplan.json
  dependencies:
    - backend-setup
  artifacts:
    name: terraform-plan-${CI_COMMIT_SHORT_SHA}
    paths:
      - ${TF_ROOT}/tfplan
      - ${TF_ROOT}/tfplan.json
    expire_in: 7 days
    reports:
      terraform: ${TF_ROOT}/tfplan.json
  needs:
    - infra-validate

# Show current state for debugging
infra-show-state:
  stage: infra-plan
  extends: .terraform-base
  script:
    - echo "=== Current Terraform State ==="
    - terraform show
    - echo "=== State List ==="
    - terraform state list || echo "No state found"
    - terraform init -reconfigure
  dependencies:
    - backend-setup
  rules:
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - Livrables/infra/**/*
      when: manual
  allow_failure: true

# Last stage: manual apply or destroy
infra-apply:
  stage: infra-deploy
  cache:
    key: terraform
    paths:
      - ${TF_ROOT}/.terraform
      - ${TF_ROOT}/.terraform.lock.hcl
  extends: .terraform-base
  script:
    - terraform apply -auto-approve tfplan
    - echo "=== Resources Created ==="
    - terraform state list
  dependencies:
    - infra-plan
    - backend-setup
  needs:
    - infra-plan
  environment:
    name: production
  rules:
    - when: manual

infra-destroy:
  stage: infra-deploy
  extends: .terraform-base
  cache:
    key: terraform
    paths:
      - ${TF_ROOT}/.terraform
      - ${TF_ROOT}/.terraform.lock.hcl
  script:
    - echo "=== Current Terraform State ==="
    - terraform init -reconfigure
    - echo "=== State List ==="
    - terraform state list || echo "No state found"
    - terraform destroy -auto-approve
    - terraform state list || echo "All resources destroyed"
  environment:
    name: production
    action: stop
  dependencies:
    - backend-setup
  rules:
    - when: manual
