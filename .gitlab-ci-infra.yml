# .gitlab-ci.yml
stages:
  - backend-setup
  - infra-validate
  - infra-plan
  - infra-deploy

variables:
  # App variables
  DOCKER_IMAGE_NAME: reddit-clone-app
  DOCKER_TAG: ${CI_COMMIT_SHORT_SHA}
  APP_ROOT: ${CI_PROJECT_DIR}/Livrables/app
  
  # Infrastructure variables
  TF_ROOT: ${CI_PROJECT_DIR}/Livrables/infra/main
  BACKEND_ROOT: ${CI_PROJECT_DIR}/Livrables/infra/backend
  TF_STATE_NAME: ${CI_COMMIT_REF_SLUG}
  TF_CACHE_KEY: ${CI_COMMIT_REF_SLUG}
  
  # Backend configuration (will be set by backend-setup job)
  TF_STATE_BUCKET: ""
  TF_STATE_LOCK_TABLE: ""
  AWS_DEFAULT_REGION: "${AWS_DEFAULT_REGION:-us-east-1}"

# =============================================================================
# BACKEND SETUP - Create S3 bucket and DynamoDB table for Terraform state
# =============================================================================

.backend-base:
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  before_script:
    - cd ${BACKEND_ROOT}
    - terraform --version
    - terraform init
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - Livrables/backend/**/*
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - Livrables/backend/**/*

# Setup the Terraform backend infrastructure
backend-setup:
  stage: backend-setup
  extends: .backend-base
  script:
    - echo "Setting up Terraform backend infrastructure..."
    - terraform validate
    - terraform plan -out=backend-plan
    - terraform apply -input=false backend-plan
    - echo "=== Backend Setup Complete ==="
    - terraform output -raw s3_bucket_name > ../s3_bucket.txt
    - terraform output -raw dynamodb_table_name > ../dynamodb_table.txt
    - echo "S3 Bucket $(cat ../s3_bucket.txt)"
    - echo "DynamoDB Table $(cat ../dynamodb_table.txt)"
  artifacts:
    paths:
      - s3_bucket.txt
      - dynamodb_table.txt
    expire_in: 1 day
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"'
      changes:
        - Livrables/backend/**/*
      when: manual
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - Livrables/backend/**/*
      when: manual

# Validate backend setup
backend-validate:
  stage: backend-setup
  extends: .backend-base
  script:
    - terraform validate
    - terraform fmt -check
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - Livrables/backend/**/*
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - Livrables/backend/**/*

# =============================================================================
# INFRASTRUCTURE PIPELINE - Uses the backend created above
# =============================================================================

.terraform-base:
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  cache:
    key: "${TF_CACHE_KEY}"
    paths:
      - ${TF_ROOT}/.terraform
      - ${TF_ROOT}/.terraform.lock.hcl
  before_script:
    - cd ${TF_ROOT}
    - terraform --version
    # Get backend configuration from setup artifacts or fallback
    - |
      if [ -f "../s3_bucket.txt" ] && [ -f "../dynamodb_table.txt" ]; then
        export TF_STATE_BUCKET=$(cat ../s3_bucket.txt)
        export TF_STATE_LOCK_TABLE=$(cat ../dynamodb_table.txt)
        echo "Using backend from setup S3=$TF_STATE_BUCKET DynamoDB=$TF_STATE_LOCK_TABLE"
      else
        # Fallback to predefined values or error
        if [ -z "$TF_STATE_BUCKET" ] || [ -z "$TF_STATE_LOCK_TABLE" ]; then
          echo "ERROR Backend not configured. Run backend-setup first or set TF_STATE_BUCKET and TF_STATE_LOCK_TABLE variables"
          exit 1
        fi
        echo "Using predefined backend S3=$TF_STATE_BUCKET DynamoDB=$TF_STATE_LOCK_TABLE"
      fi
    # Create backend configuration for S3
    - |
      cat > backend.tf << EOF
      terraform {
        backend "s3" {
          bucket         = "${TF_STATE_BUCKET}"
          key            = "environments/${TF_STATE_NAME}/terraform.tfstate"
          region         = "${AWS_DEFAULT_REGION}"
          dynamodb_table = "${TF_STATE_LOCK_TABLE}"
          encrypt        = true
        }
      }
      EOF
    - terraform init -reconfigure
  dependencies:
    - backend-setup
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - Livrables/infra/**/*
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - Livrables/infra/**/*

# Validate Terraform configuration
infra-validate:
  stage: infra-validate
  extends: .terraform-base
  script:
    - terraform validate
    - terraform fmt -check

# Security scanning for Terraform
infra-security-scan:
  stage: infra-validate
  image:
    name: aquasec/tfsec:latest
    entrypoint: [""]
  script:
    - tfsec ${TF_ROOT} --format junit --out tfsec-report.xml || true
  artifacts:
    reports:
      junit: tfsec-report.xml
    when: always
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - Livrables/infra/**/*
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - Livrables/infra/**/*
  allow_failure: true

# Plan Terraform changes
infra-plan:
  stage: infra-plan
  extends: .terraform-base
  script:
    - terraform plan -input=false -out=tfplan
    - terraform show -json tfplan > tfplan.json
  artifacts:
    name: terraform-plan-${CI_COMMIT_SHORT_SHA}
    paths:
      - ${TF_ROOT}/tfplan
      - ${TF_ROOT}/tfplan.json
    expire_in: 7 days
    reports:
      terraform: ${TF_ROOT}/tfplan.json

# Show current state for debugging
infra-show-state:
  stage: infra-plan
  extends: .terraform-base
  script:
    - echo "=== Current Terraform State ==="
    - terraform show
    - echo "=== State List ==="
    - terraform state list || echo "No state found"
    - echo "=== Workspace ==="
    - terraform workspace show
  rules:
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - Livrables/infra/**/*
      when: manual
  allow_failure: true

# Apply infrastructure changes to staging
infra-apply-staging:
  stage: infra-deploy
  extends: .terraform-base
  script:
    - terraform apply -input=false tfplan
    - echo "=== Resources Created ==="
    - terraform state list
  dependencies:
    - infra-plan
  environment:
    name: staging-infra
    on_stop: infra-destroy-staging
  rules:
    - if: '$CI_COMMIT_BRANCH == "develop"'
      changes:
        - Livrables/infra/**/*
      when: on_success
    - if: '$CI_COMMIT_BRANCH != "develop"'
      changes:
        - Livrables/infra/**/*
      when: manual

# Apply infrastructure changes to production
infra-apply-production:
  stage: infra-deploy
  extends: .terraform-base
  script:
    - terraform apply -input=false tfplan
    - echo "=== Resources Created ==="
    - terraform state list
  dependencies:
    - infra-plan
  environment:
    name: production-infra
    on_stop: infra-destroy-production
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"'
      changes:
        - Livrables/infra/**/*
      when: manual

# Destroy staging infrastructure
infra-destroy-staging:
  stage: infra-deploy
  extends: .terraform-base
  script:
    - echo "=== Current State Before Destroy ==="
    - terraform state list || echo "No state found"
    - terraform show || echo "No resources to show"
    - echo "=== Destroying Infrastructure ==="
    - terraform destroy -auto-approve
    - echo "=== State After Destroy ==="
    - terraform state list || echo "All resources destroyed"
  environment:
    name: staging-infra
    action: stop
  rules:
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - Livrables/infra/**/*
      when: manual

# Destroy production infrastructure  
infra-destroy-production:
  stage: infra-deploy
  extends: .terraform-base
  script:
    - echo "=== Current State Before Destroy ==="
    - terraform state list || echo "No state found"
    - terraform show || echo "No resources to show"
    - echo "=== Destroying Infrastructure ==="
    - terraform destroy -auto-approve
    - echo "=== State After Destroy ==="
    - terraform state list || echo "All resources destroyed"
  environment:
    name: production-infra
    action: stop
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"'
      changes:
        - Livrables/infra/**/*
      when: manual