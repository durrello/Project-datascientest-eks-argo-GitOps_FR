stages:
  - validate
  - plan
  - deploy-infra
  - deploy-apps

variables:
  TERRAFORM_VERSION: "1.6.6"
  TF_ROOT: "Livrables/EKS-TF"
  TF_STATE_NAME: "default"
  TF_CLI_CONFIG_FILE: "/tmp/.terraformrc"
  EKS_CLUSTER_NAME: "fall-project-cluster"

# Use Ubuntu-based image with better compatibility
image: ubuntu:22.04

before_script:
  - cd $TF_ROOT
  # Update package list
  - apt-get update -y
  # Install required packages
  - apt-get install -y curl unzip wget python3 python3-pip git
  # Install Terraform
  - wget https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
  - unzip terraform_${TERRAFORM_VERSION}_linux_amd64.zip
  - mv terraform /usr/local/bin/
  - terraform --version
  # Install AWS CLI v2
  - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  - unzip awscliv2.zip
  - ./aws/install
  - aws --version
  # Install kubectl
  - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
  - chmod +x kubectl
  - mv kubectl /usr/local/bin/
  - kubectl version --client
  # Configure AWS credentials using GitLab CI variables
  - aws configure set aws_access_key_id $TF_VAR_AWS_ACCESS_KEY_ID
  - aws configure set aws_secret_access_key $TF_VAR_AWS_SECRET_ACCESS_KEY
  - aws configure set default.region $TF_VAR_AWS_DEFAULT_REGION
  # Export AWS environment variables for compatibility
  - export AWS_ACCESS_KEY_ID=$TF_VAR_AWS_ACCESS_KEY_ID
  - export AWS_SECRET_ACCESS_KEY=$TF_VAR_AWS_SECRET_ACCESS_KEY
  - export AWS_DEFAULT_REGION=$TF_VAR_AWS_DEFAULT_REGION
  # Setup Terraform Cloud credentials if using Terraform Cloud
  - |
    if [ ! -z "$TF_API_TOKEN" ]; then
      echo "Setting up Terraform Cloud credentials..."
      mkdir -p ~/.terraform.d
      echo "credentials \"app.terraform.io\" { token = \"$TF_API_TOKEN\" }" > ~/.terraform.d/credentials.tfrc.json
      echo 'credentials "app.terraform.io" { token = "'$TF_API_TOKEN'" }' > /tmp/.terraformrc
    fi
  # Initialize with backend configuration
  - terraform init -backend=true

# Validate terraform configuration
terraform:validate:
  stage: validate
  script:
    - terraform validate
  only:
    - branches

# Plan terraform changes
terraform:plan:
  stage: plan
  script:
    # Try to update kubeconfig (may fail if cluster doesn't exist yet)
    - aws eks update-kubeconfig --region $TF_VAR_AWS_DEFAULT_REGION --name $EKS_CLUSTER_NAME || echo "EKS cluster not found, continuing with plan..."
    - terraform plan -out="planfile"
  artifacts:
    paths:
      - $TF_ROOT/planfile
    expire_in: 1 week
  only:
    - branches

# Apply infrastructure (EKS cluster and AWS resources)
terraform:apply-infra:
  stage: deploy-infra
  script:
    # First apply only AWS infrastructure (EKS cluster, VPC, etc.)
    - terraform apply -input=false -target=module.networking "planfile" || terraform apply -input=false -target=module.networking
    - terraform apply -input=false -target=module.eks "planfile" || terraform apply -input=false -target=module.eks
    # Wait for EKS cluster to be ready
    - sleep 60
    - aws eks update-kubeconfig --region $TF_VAR_AWS_DEFAULT_REGION --name $EKS_CLUSTER_NAME
    - kubectl get nodes --timeout=300s || echo "Waiting for nodes to be ready..."
  dependencies:
    - terraform:plan
  only:
    - main
    - master
  when: manual

# Apply applications (Kubernetes resources)
terraform:apply-apps:
  stage: deploy-apps
  script:
    # Update kubeconfig
    - aws eks update-kubeconfig --region $TF_VAR_AWS_DEFAULT_REGION --name $EKS_CLUSTER_NAME
    # Apply remaining Kubernetes resources
    - terraform apply -input=false "planfile"
  dependencies:
    - terraform:apply-infra
  only:
    - main
    - master
  when: manual

# Keep the original apply job for simpler deployments
terraform:apply:
  stage: deploy-infra
  script:
    # Update kubeconfig for EKS access (after cluster is created)
    - sleep 30  # Give EKS cluster time to be ready
    - aws eks update-kubeconfig --region $TF_VAR_AWS_DEFAULT_REGION --name $EKS_CLUSTER_NAME || echo "Waiting for EKS cluster to be ready..."
    - terraform apply -input=false "planfile"
  dependencies:
    - terraform:plan
  only:
    - main
    - master
  when: manual  # Require manual approval for deployment

# Optional: Destroy infrastructure (manual trigger only)
terraform:destroy:
  stage: deploy-apps
  script:
    # Update kubeconfig for EKS access
    - aws eks update-kubeconfig --region $TF_VAR_AWS_DEFAULT_REGION --name $EKS_CLUSTER_NAME
    - terraform destroy -auto-approve
  only:
    - main
    - master
  when: manual
  allow_failure: false