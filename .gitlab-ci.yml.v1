stages:
  - validate
  - security
  - plan
  - apply
  - destroy

variables:
  TF_ROOT: "Livrables/EKS-TF"
  TERRAFORM_VERSION: "1.6.6"
  GIT_SUBMODULE_STRATEGY: recursive
  # Prevent Terraform from buffering output
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"
  # Add timeout configurations
  TF_VAR_helm_timeout: "600"
  HELM_TIMEOUT: "600s"

# Global cache for better performance
cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - ${TF_ROOT}/.terraform/
    - ${TF_ROOT}/.terraform.lock.hcl

default:
  image: ubuntu:22.04
  before_script:
    - export DEBIAN_FRONTEND=noninteractive
    - apt-get update -q
    - apt-get install -y -q bash curl unzip git jq python3 python3-pip ca-certificates
    
    # Install AWS CLI v2 (cached installation check)
    - |
      if [ ! -f "/usr/local/bin/aws" ]; then
        echo "Installing AWS CLI v2..."
        curl -s "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
        unzip -q awscliv2.zip
        ./aws/install
        rm -rf aws awscliv2.zip
      fi
    - aws --version
    
    # Install Terraform (cached installation check)
    - |
      if [ ! -f "/usr/local/bin/terraform" ] || [ "$(/usr/local/bin/terraform version -json 2>/dev/null | jq -r '.terraform_version' 2>/dev/null)" != "${TERRAFORM_VERSION}" ]; then
        echo "Installing Terraform ${TERRAFORM_VERSION}..."
        curl -fsSL "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip" -o terraform.zip
        unzip -q terraform.zip -d /usr/local/bin/
        rm terraform.zip
      fi
    - terraform version
    
    # Install kubectl for EKS operations
    - |
      if [ ! -f "/usr/local/bin/kubectl" ]; then
        echo "Installing kubectl..."
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        mv kubectl /usr/local/bin/
      fi
    - kubectl version --client
    
    # Install Helm
    - |
      if [ ! -f "/usr/local/bin/helm" ]; then
        echo "Installing Helm..."
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
      fi
    - helm version
    
    # Configure AWS credentials
    - export AWS_ACCESS_KEY_ID="$TF_VAR_AWS_ACCESS_KEY_ID"
    - export AWS_SECRET_ACCESS_KEY="$TF_VAR_AWS_SECRET_ACCESS_KEY"
    - export AWS_DEFAULT_REGION="$TF_VAR_AWS_DEFAULT_REGION"
    - aws sts get-caller-identity || { echo "AWS credentials validation failed"; exit 1; }

# -----------------
# 1. Terraform validate
# -----------------
terraform:validate:
  stage: validate
  script:
    - cd $TF_ROOT
    - echo "Validating Terraform configuration..."
    - terraform init -backend=false -upgrade
    - terraform fmt -check=true -diff=true || echo "⚠️ Code formatting issues found"
    - terraform validate
    - echo "✅ Terraform validation completed"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH'

# -----------------
# 2. Security Scan with Trivy
# -----------------
terraform:security-scan:
  stage: security
  image: ubuntu:22.04
  before_script:
    - export DEBIAN_FRONTEND=noninteractive
    - apt-get update -q
    - apt-get install -y -q bash curl unzip git wget ca-certificates
    - |
      echo "Installing Trivy..."
      curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
  script:
    - cd $TF_ROOT
    - echo "Running security scan..."
    - trivy config . --exit-code 1 --severity HIGH,CRITICAL --format table || echo "⚠️ Security issues found - review before proceeding"
    - echo "✅ Security scan completed"
  allow_failure: true
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH'

# -----------------
# 3. Terraform Plan
# -----------------
terraform:plan:
  stage: plan
  script:
    - cd $TF_ROOT
    - echo "Initializing Terraform with backend..."
    - terraform init -upgrade
    
    # Validate the configuration after init
    - terraform validate
    
    # Check for state lock and force unlock if necessary
    - |
      echo "Checking for state locks..."
      terraform force-unlock -force $(terraform show -json 2>/dev/null | jq -r '.values.root_module.resources[] | select(.type == "terraform_remote_state") | .values.lock_id' 2>/dev/null) || echo "No locks to clear"
    
    - echo "Creating Terraform execution plan..."
    - terraform plan -out=tfplan -lock-timeout=600s -var="helm_timeout=600"
    
    - echo "Generating human-readable plan..."
    - terraform show -no-color tfplan > plan.txt || echo "Plan output generation failed but continuing..."
    
    - echo "✅ Terraform plan completed successfully"
    - echo "Plan summary:"
    - grep -E "^Plan:|^No changes" plan.txt || echo "Plan details available in artifacts"
  artifacts:
    paths:
      - ${TF_ROOT}/tfplan
      - ${TF_ROOT}/plan.txt
      - ${TF_ROOT}/.terraform.lock.hcl
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - if: '$CI_COMMIT_BRANCH == "master"'  
      when: manual
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: manual

# -----------------
# 4. Terraform Apply with Enhanced Error Handling
# -----------------
terraform:apply:
  stage: apply
  environment:
    name: production
    action: start
  timeout: 45m  # Extended timeout for Helm installations
  script:
    - cd $TF_ROOT
    - echo "Verifying plan file exists..."
    - ls -la tfplan || { echo "❌ Plan file not found"; exit 1; }
    
    - echo "Re-initializing Terraform to ensure consistency..."
    - terraform init
    
    # Check if plan is still valid by refreshing state first
    - echo "Refreshing Terraform state to check for drift..."
    - terraform plan -detailed-exitcode -out=tfplan-refresh -lock-timeout=600s -var="helm_timeout=600" || PLAN_EXIT_CODE=$?
    
    - |
      if [ "${PLAN_EXIT_CODE:-0}" -eq 2 ]; then
        echo "⚠️ State has drifted, using fresh plan..."
        mv tfplan-refresh tfplan
      elif [ "${PLAN_EXIT_CODE:-0}" -eq 1 ]; then
        echo "❌ Plan validation failed"
        exit 1
      else
        echo "✅ Original plan is still valid"
      fi
    
    # Configure Helm timeout
    - export HELM_TIMEOUT=600s
    
    - echo "Applying Terraform plan with extended timeouts..."
    - terraform apply -auto-approve -lock-timeout=600s tfplan
    
    # Verify EKS cluster is ready
    - |
      if terraform output cluster_name 2>/dev/null; then
        CLUSTER_NAME=$(terraform output -raw cluster_name)
        echo "Configuring kubectl for cluster: $CLUSTER_NAME"
        aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name $CLUSTER_NAME
        
        echo "Waiting for cluster to be ready..."
        kubectl wait --for=condition=Ready nodes --all --timeout=300s || echo "⚠️ Some nodes may not be ready yet"
        
        echo "Cluster status:"
        kubectl get nodes
      fi
    
    - echo "✅ Terraform apply completed successfully"
    - echo "Final outputs:"
    - terraform output || echo "No outputs defined"
  dependencies:
    - terraform:plan
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: manual
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

# -----------------
# 5. Helm Install Retry Job (For Failed Helm Releases)
# -----------------
helm:retry-install:
  stage: apply
  script:
    - cd $TF_ROOT
    - terraform init
    
    # Configure kubectl
    - |
      if terraform output cluster_name 2>/dev/null; then
        CLUSTER_NAME=$(terraform output -raw cluster_name)
        aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name $CLUSTER_NAME
      fi
    
    # Retry failed Helm releases with increased timeout
    - |
      echo "Checking for failed Helm releases..."
      
      # Check ArgoCD
      if helm list -n argocd | grep -q "FAILED"; then
        echo "Retrying ArgoCD installation..."
        helm uninstall argocd -n argocd --timeout=300s || true
        kubectl delete namespace argocd --timeout=300s || true
        sleep 30
        terraform apply -target=module.argocd.helm_release.argocd -auto-approve -var="helm_timeout=600"
      fi
      
      # Check Cert Manager
      if helm list -n cert-manager | grep -q "FAILED"; then
        echo "Retrying Cert Manager installation..."
        helm uninstall cert-manager -n cert-manager --timeout=300s || true
        kubectl delete namespace cert-manager --timeout=300s || true
        sleep 30
        terraform apply -target=module.cert_manager -auto-approve -var="helm_timeout=600"
      fi
      
      # Check Velero
      if helm list -n velero | grep -q "FAILED"; then
        echo "Retrying Velero installation..."
        helm uninstall velero -n velero --timeout=300s || true
        kubectl delete namespace velero --timeout=300s || true
        sleep 30
        terraform apply -target=module.velero -auto-approve -var="helm_timeout=600"
      fi
      
    - echo "✅ Helm retry operations completed"
  dependencies:
    - terraform:apply
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: manual
  allow_failure: true

# -----------------
# 6. Terraform Destroy (Standalone)
# -----------------
terraform:destroy-direct:
  stage: plan
  environment:
    name: production
    action: stop
  script:
    - cd $TF_ROOT
    - echo "Initializing Terraform for destroy operation..."
    - terraform init
    
    # Safety check
    - |
      if [ "$DESTROY_CONFIRMED" != "yes" ]; then
        echo "❌ Destruction not confirmed. Set CI/CD variable DESTROY_CONFIRMED=yes to proceed."
        exit 1
      fi
    
    - echo "Creating destroy plan..."
    - terraform plan -destroy -out=destroy-plan
    
    - echo "Applying destroy plan..."
    - terraform apply -auto-approve destroy-plan
    
    - echo "✅ Infrastructure destroyed successfully"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: manual
  allow_failure: false

# -----------------
# 7. Terraform Destroy (After Apply)
# -----------------
terraform:destroy-after-apply:
  stage: destroy
  environment:
    name: production
    action: stop
  script:
    - cd $TF_ROOT
    - echo "Initializing Terraform for destroy operation..."
    - terraform init
    
    # Safety check
    - |
      if [ "$DESTROY_CONFIRMED" != "yes" ]; then
        echo "❌ Destruction not confirmed. Set CI/CD variable DESTROY_CONFIRMED=yes to proceed."
        exit 1
      fi
    
    # Clean up EKS resources first if they exist
    - |
      if terraform output cluster_name 2>/dev/null; then
        echo "Cleaning up EKS resources..."
        CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "fall-project-cluster")
        aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name $CLUSTER_NAME || echo "⚠️ Cluster may not exist"
        
        # Remove finalizers from stuck resources
        kubectl patch crd/certificates.cert-manager.io -p '{"metadata":{"finalizers":[]}}' --type=merge || true
        kubectl patch crd/orders.acme.cert-manager.io -p '{"metadata":{"finalizers":[]}}' --type=merge || true
        
        # Clean up Helm releases
        helm list --all-namespaces | grep -v NAME | awk '{print $1" -n "$2}' | xargs -I {} helm uninstall {} --timeout=300s || true
        
        # Delete all resources
        kubectl delete all --all --all-namespaces --timeout=300s || echo "⚠️ Failed to clean up Kubernetes resources"
        
        # Delete persistent volumes
        kubectl delete pv --all --timeout=300s || true
      fi
    
    - echo "Destroying infrastructure..."
    - terraform destroy -auto-approve -lock-timeout=600s
    
    - echo "✅ Infrastructure destroyed successfully"
  dependencies:
    - terraform:apply
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: manual
  allow_failure: false